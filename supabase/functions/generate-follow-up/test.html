<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TF-IDF Test - No Installation Required</title>
    <style>
        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 { color: #4ec9b0; }
        h2 { color: #569cd6; margin-top: 30px; }
        .test-section {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .pass { color: #4ec9b0; }
        .info { color: #ce9178; }
        .score { color: #dcdcaa; }
        pre {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
        }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 0;
        }
        button:hover {
            background: #1177bb;
        }
        .question-item {
            padding: 10px;
            margin: 5px 0;
            background: #2d2d30;
            border-left: 3px solid #569cd6;
            border-radius: 4px;
        }
        #output {
            white-space: pre-wrap;
            font-family: 'Monaco', 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <h1>üß™ TF-IDF Question Generator Test</h1>
    <p class="info">‚ú® No installation required - runs in your browser!</p>

    <div class="test-section">
        <h2>üìù Sample Journal Entries</h2>
        <textarea id="entries" rows="10" style="width: 100%; background: #1e1e1e; color: #d4d4d4; border: 1px solid #3e3e42; padding: 10px; font-family: monospace;">Today was really stressful at work. I had three deadlines and felt completely overwhelmed. I need to learn better time management and set boundaries with my team.

Feeling anxious about the upcoming presentation. I always get nervous speaking in front of people. Maybe I should practice more or try some breathing exercises.

Spent quality time with family today. It reminded me how important it is to disconnect from work and be present. Grateful for these moments of peace.</textarea>
        <p style="color: #858585; font-size: 12px;">Edit the entries above to test different scenarios</p>
    </div>

    <button onclick="runTest()">‚ñ∂Ô∏è Run TF-IDF Analysis</button>

    <div class="test-section">
        <h2>üìä Results</h2>
        <div id="output"></div>
    </div>

    <script>
        // TF-IDF Implementation
        function tokenize(text) {
            return text
                .toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(word => word.length > 2);
        }

        const STOP_WORDS = new Set([
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
            'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'been', 'be',
            'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
            'should', 'may', 'might', 'can', 'this', 'that', 'these', 'those',
            'i', 'you', 'he', 'she', 'it', 'we', 'they', 'my', 'your', 'his',
            'her', 'its', 'our', 'their', 'me', 'him', 'them', 'us', 'am'
        ]);

        function removeStopWords(tokens) {
            return tokens.filter(token => !STOP_WORDS.has(token));
        }

        function computeTF(tokens) {
            const tf = new Map();
            const totalTokens = tokens.length;
            if (totalTokens === 0) return tf;

            for (const token of tokens) {
                tf.set(token, (tf.get(token) || 0) + 1);
            }

            for (const [word, count] of tf.entries()) {
                tf.set(word, count / totalTokens);
            }

            return tf;
        }

        function computeIDF(documents) {
            const idf = new Map();
            const totalDocs = documents.length;
            if (totalDocs === 0) return idf;

            const wordDocCount = new Map();
            for (const doc of documents) {
                const uniqueWords = new Set(doc);
                for (const word of uniqueWords) {
                    wordDocCount.set(word, (wordDocCount.get(word) || 0) + 1);
                }
            }

            for (const [word, docCount] of wordDocCount.entries()) {
                idf.set(word, Math.log(totalDocs / docCount));
            }

            return idf;
        }

        function computeTFIDF(tokens, idf) {
            const tf = computeTF(tokens);
            const tfidf = new Map();

            for (const [word, tfScore] of tf.entries()) {
                const idfScore = idf.get(word) || 0;
                tfidf.set(word, tfScore * idfScore);
            }

            return tfidf;
        }

        function cosineSimilarity(vec1, vec2) {
            let dotProduct = 0;
            let magnitude1 = 0;
            let magnitude2 = 0;

            const allWords = new Set([...vec1.keys(), ...vec2.keys()]);

            for (const word of allWords) {
                const val1 = vec1.get(word) || 0;
                const val2 = vec2.get(word) || 0;

                dotProduct += val1 * val2;
                magnitude1 += val1 * val1;
                magnitude2 += val2 * val2;
            }

            magnitude1 = Math.sqrt(magnitude1);
            magnitude2 = Math.sqrt(magnitude2);

            if (magnitude1 === 0 || magnitude2 === 0) return 0;

            return dotProduct / (magnitude1 * magnitude2);
        }

        // Question Bank
        const questionBank = [
            { id: 'q001', text: 'What boundaries do you need to set to protect your energy?', keywords: ['boundary', 'energy', 'protect', 'limit', 'space', 'overwhelm', 'drain', 'tired', 'exhausted'] },
            { id: 'q002', text: 'What strategies help you manage stress effectively?', keywords: ['stress', 'anxious', 'worry', 'overwhelm', 'pressure', 'deadline', 'manage', 'cope'] },
            { id: 'q003', text: 'How can you communicate your needs more clearly at work?', keywords: ['work', 'team', 'communicate', 'needs', 'express', 'ask', 'help', 'support'] },
            { id: 'q004', text: 'What small step can you take to build confidence in challenging situations?', keywords: ['anxious', 'nervous', 'afraid', 'scared', 'worry', 'confidence', 'challenge', 'difficult'] },
            { id: 'q005', text: 'When do you feel most at ease, and how can you create more of those moments?', keywords: ['anxious', 'calm', 'peace', 'ease', 'relax', 'breathe', 'safe', 'comfortable'] },
            { id: 'q006', text: 'What relationships in your life deserve more attention?', keywords: ['family', 'friend', 'love', 'relationship', 'connection', 'time', 'quality', 'present'] },
            { id: 'q007', text: 'How did you show yourself compassion today?', keywords: ['compassion', 'kind', 'gentle', 'care', 'support', 'love', 'accept', 'forgive'] },
            { id: 'q008', text: 'What patterns are you noticing in your emotional responses?', keywords: ['pattern', 'notice', 'realize', 'aware', 'recognize', 'emotion', 'feel', 'react'] },
            { id: 'q009', text: 'How could more preparation support your peace of mind?', keywords: ['prepare', 'practice', 'ready', 'plan', 'nervous', 'presentation', 'speaking', 'public'] },
            { id: 'q010', text: 'What helps you truly disconnect and be present?', keywords: ['present', 'disconnect', 'mindful', 'aware', 'moment', 'now', 'focus', 'attention'] }
        ];

        function runTest() {
            const output = document.getElementById('output');
            const entriesText = document.getElementById('entries').value;

            // Split entries by double newline
            const entries = entriesText.split('\n\n').filter(e => e.trim());

            let result = 'üß™ TF-IDF Analysis Results\n';
            result += '='.repeat(60) + '\n\n';

            result += `üìù Analyzing ${entries.length} journal entries\n`;
            result += `üìä Total text length: ${entriesText.length} characters\n\n`;

            // Process entries
            const combinedText = entries.join(' ');
            const userTokens = removeStopWords(tokenize(combinedText));

            result += `üî§ Extracted ${userTokens.length} unique tokens\n\n`;

            // Compute IDF
            const allDocs = entries.map(e => removeStopWords(tokenize(e)));
            const docIDF = computeIDF(allDocs);
            const userVector = computeTFIDF(userTokens, docIDF);

            // Show top terms from entries
            result += 'üìà Top 10 Terms from Your Entries:\n';
            result += '-'.repeat(60) + '\n';
            const sortedTerms = Array.from(userVector.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            sortedTerms.forEach(([word, score]) => {
                result += `  ${word.padEnd(15)} ${score.toFixed(4)}\n`;
            });
            result += '\n';

            // Pre-compute question vectors
            const questionDocs = questionBank.map(q => removeStopWords(tokenize(q.keywords.join(' '))));
            const questionIDF = computeIDF(questionDocs);
            const precomputedQuestions = questionBank.map((question, idx) => ({
                question,
                vector: computeTFIDF(questionDocs[idx], questionIDF)
            }));

            // Compute similarity
            const scoredQuestions = precomputedQuestions.map(({ question, vector }) => ({
                question,
                score: cosineSimilarity(userVector, vector)
            }));

            scoredQuestions.sort((a, b) => b.score - a.score);

            // Display results
            result += 'üéØ Top 5 Recommended Questions:\n';
            result += '='.repeat(60) + '\n\n';
            scoredQuestions.slice(0, 5).forEach((q, idx) => {
                result += `${idx + 1}. [Score: ${q.score.toFixed(4)}]\n`;
                result += `   ${q.question.text}\n\n`;
            });

            result += '\n‚úÖ Analysis Complete!\n';
            result += '\n‚ÑπÔ∏è  Higher scores = better match to your entries\n';
            result += '‚ÑπÔ∏è  Try editing the entries above to see different results';

            output.textContent = result;
        }

        // Run on page load
        window.onload = () => runTest();
    </script>
</body>
</html>
